<%= javascript_include_tag "jszip.min.js" %>
<%= javascript_include_tag "Chart.bundle.js" %>

<style>
.hideContent {
    overflow: hidden;
    line-height: 1em;
    height: 2em;
}

.showContent {
    line-height: 1em;
    height: auto;
}

.show-more {
    padding: 10px 0;
    text-align: right;
}

</style>

<% content_for :title, "Router ETA Accuracy" %>
    <div class="ctrl-panel">
        <span id="toggle-ctrl-panel" class="glyphicon glyphicon-menu-left"></span>
        <h5> This example compares the estimated time to arrival (ETA) and route of the HLS router with Fleet/CRE router.</h5>
            <div class="content hideContent">
            <ul style="list-style-type:square">
                <li>Add waypoints for the route by using right clicks on to the map, or copy waypoint list, or add a trace file.</li>
                <li>For adding waypoint list copy them into the "Waypoints:" section below in format "seq nr, lat, long"</li>
                <li>You can also select route start & end waypoints from a trace file. Copy or drag and drop your trace file into the "Trace file:" section below.</li>
                <li>Click on "Route" button below to start route calculations. Using a trace file triggers an RME route match as well.</li>
                <li>Click on the graph curves generated to see data point on respective route link on the map.</li>
            </ul>
        </div>
        <div class="show-more">
            <a style="color:blue;" href="#">Show more</a>
        </div> <br>
        <div class="form-horizontal">

            <div class="form-group">
                <label class="control-label col-sm-2" for="exampleSelector">Examples:</label>
                <div class="col-sm-10">
                    <select id="exampleSelector" class="form-control" onchange="exampleSelect(this)"></select>
				</div>
            </div>
            <div class="form-group">
                <label class="control-label col-sm-2">Way points:</label>
                <div class="col-sm-10">
                    <textarea id="waypoints" class="form-control" rows="4" cols="42" placeholder="way points can be generated by trace file &#10;or added by right-click into map"></textarea>
                </div>
            </div>
            <div class="form-group">
                <label class="control-label col-sm-2"><font color="blue">HLS Route Request:</font></label>
                <div class="col-sm-10">
                    <textarea id="hlp_router_endpoint" class="form-control" rows="2" cols="42" wrap="virtual">https://route.api.here.com/routing/7.2/calculateroute.json&#10;?mode=fastest;car;traffic:disabled&#10;&jsonAttributes=41&legattributes=li&linkattributes=sh,rt</textarea>
                </div>
            </div>
            <div class="form-group">
                <label class="control-label col-sm-2"><font color="green">CRE Route Request:</font></label>
                <div class="col-sm-10">
					<textarea id="fleet_router_endpoint" class="form-control" rows="2" cols="42" wrap="virtual">https://cre.api.here.com/2/calculateroute.json&#10;?mode=fastest;car;traffic:disabled&#10;&driver_cost=30&traverseGates=true&ignoreWaypointVehicleRestriction=10000</textarea>
                    <!-- <textarea id="fleet_router_endpoint" class="form-control" rows="2" cols="42" wrap="virtual">http://localhost:8080/cle/2/calculateroute.json&#10;?mode=fastest;car;traffic:disabled&#10;&driver_cost=30&traverseGates=true&ignoreWaypointVehicleRestriction=10000</textarea> -->
                </div>
				<div class="col-sm-10" id="feedbackModeModification"></div>														   
            </div>
            <div class="form-group">
                <label class="control-label col-sm-2"><font color="#ff0080">RME Request:</font></label>
                <div class="col-sm-10">
                    <textarea id="rme_endpoint" class="form-control" rows="2" cols="42" wrap="virtual">https://fleet.api.here.com/2/calculateroute.json&#10;?routeMatch=1&mode=fastest;car;traffic:disabled</textarea> <!--&#10; is the line feed character -->
                    <!-- <textarea id="rme_endpoint" class="form-control" rows="2" cols="42" wrap="virtual">http://localhost:8080/cle/2/calculateroute.json&#10;?routeMatch=1&mode=fastest;car;traffic:disabled</textarea> --> <!--&#10; is the line feed character -->
                </div>
            </div>

            <div class="form-group">
                <label class="control-label col-sm-2"><font color="#ff0080">Trace file:</font></label>
                <div class="col-sm-10">
                    <textarea id="tracetextarea" class="form-control" rows="4" placeholder="Drag &amp; drop trace file here"></textarea>
                </div>
            </div>

			<canvas id="chartContainer" style:"auto"></canvas>
            
            <div class="form-group">
                <input class="control-label col-sm-2" id="suppressBreakDuration" type="checkbox" autocomplete="off" onclick="toggleRmeEta(this)"/>Suppress break duration in RME ETA
                <!--<label for="suppressBreakDuration" >Suppress break duration detected in Trace file ETA</label>-->
            </div>

            <div class="form-group">
				<input class="btn btn-default btn-sm col-sm-2" type="button" id="b1" value="Route" onclick="calculateRoute()">
                <div class="col-sm-10" id="feedbackTxt">Click onto a curve in graph --> see on map. Click on link in map --> see in graph.</div>
                <div class="col-sm-10" id="feedbackTxtRME"></div>
                <div class="col-sm-10" id="feedbackTxtChartPoint"></div>
			</div>
        </div>
    </div>

    <style>
        #notecontent a { color: white; }
        #notecontent a:hover { color: red; }
        table td, table td * { vertical-align: top; }
        textarea { white-space: pre; word-wrap: normal; overflow: scroll; }
        li.accStarts, li.accEnds { color: #59b354; }
        li.stStarts, li.stEnds { color: #1b5fcc; }
        li.arr { color: red; }
        li.dep { color: white; }
        li.at { color: yellow; }
        .menubkg { background-color: #f8f8f8; border-radius: 15px; color: black; }
        .menubkg select { font-size: 10px; vertical-align: middle; }
        .menubkg select option:checked { background-color: #999; }
    </style>

    <div id="mapContainer"></div>
	<div id="spinner"></div>
    <div id="pageblock"></div>						

    <script type="text/javascript">
        /**
         * @author Wolfgang Becker, Muhammad Faheem
         * (C) HERE 2017 - 2018
         */
    
       $(document).ready(function() {});
       document.getElementById('chartContainer').style.display = 'none';
        var feedbackTxt = document.getElementById("feedbackTxt");
        var feedbackTxtRME = document.getElementById("feedbackTxtRME");
        var feedbackTxtChartPoint = document.getElementById("feedbackTxtChartPoint");
		var feedbackModeModification = document.getElementById("feedbackModeModification");																				   
        var hidpi = ('devicePixelRatio' in window && devicePixelRatio > 1);
        var mapContainer = document.getElementById('mapContainer');
        var platform = new H.service.Platform({ app_code: app_code, app_id: app_id, useHTTPS: true }),
            maptypes = platform.createDefaultLayers(hidpi ? 512 : 256, hidpi ? 320 : null),
            labels = new H.map.Group(),
            basemaptileService = platform.getMapTileService({ 'type': 'base' }),
            greyTileLayer = basemaptileService.createTileLayer("maptile", "normal.day.grey", hidpi ? 512 : 256, "png8", null);
        
        map = new H.Map(mapContainer,  maptypes.normal.map, { center: {lat: 50.11035, lng: 8.68217}, zoom: 17 });

        map.getViewPort().setPadding(0, 0, 0, $('.ctrl-panel').width());        // Do not draw under control panel
        map.getViewPort().setPadding(0, 0, 0, $('.ctrl-panel').width());        // set padding for control panel
        map.addObject(labels);        											// add labels (waypoint markers) to map
        new H.mapevents.Behavior(new H.mapevents.MapEvents(map));   		    // add behavior control, e.g. for mouse
        var ui = H.ui.UI.createDefault(map, maptypes);                          // enable UI components and remove the unnecessary
        ui.removeControl('panorama');
        ui.removeControl('mapsettings');

        var groupClickedWaypoints = new H.map.Group();
        groupClickedWaypoints.setZIndex(1); 
        map.addObject(groupClickedWaypoints);
        window.addEventListener('resize', function() { map.getViewPort().resize(); });

        var groupHLP        = new H.map.Group();
        groupHLP.setZIndex(2); 
		var groupFleet      = new H.map.Group();
        groupFleet.setZIndex(1); 
        var groupRME        = new H.map.Group();
        var groupDiffMarker = new H.map.Group();
        var groupRelevantWayPoints = new H.map.Group();
		var routeLinkInfos; // key = linkId, value = drivingTime[Hls/Fleet/Rme], drivingDistance[Hls/Fleet/Rme], speedKmh[Hls/Fleet/Rme], fc, coord, linkId
		var initialRemainTimeHLSRouter  = 0;
        var initialRemoaTimeFleetRouter = 0;
		var markerOnRoute;
		var colorHls = "blue", colorFleet = "green", colorRme = "#ff0080";
        // flag and data storage for controlling rme eta behavior on graph
        var routeCalculated = false;
        var rmeDataPoints = [];
        var rmeDataPointWithoutBreaks = [];
        var feedbackTxtRMEWithBreaks = "";
        var feedbackTxtRMEWithoutBreaks = "";

        function toggleRmeEta(element){
            var suppressBreakDuration = document.getElementById("suppressBreakDuration").checked;
            if (suppressBreakDuration){
                chart.config.data.datasets[2].data = rmeDataPointWithoutBreaks;
                chart.update();
                feedbackTxtRME.innerHTML = feedbackTxtRMEWithoutBreaks;
            }
            else {
                chart.config.data.datasets[2].data = rmeDataPoints;
                chart.update();
                feedbackTxtRME.innerHTML = feedbackTxtRMEWithBreaks;
            }
        }
		
        /**
        *   A waypoint for display using markers
        */
        function Waypoints(idx, lat, lng) {
            this.idx = idx;
            this.lat = lat;
            this.lng = lng;
        }
        var ctx = document.getElementById("chartContainer");
        Chart.defaults.global.elements.point.radius = 0.1;
        var chart = new Chart(ctx,
		{
		    type: 'scatter',
            legend: {
             position: "left",
             fontSize: 5
           },
            options: {
               scales: {
                   xAxes: [{
                	   min: -45,
                	   maxTicksLimit: 10000,
                	   scaleLabel: {
                	        display: true,
                	        labelString: 'time [min]'
                	      }
                   }],
                   yAxes: [{
                	   scaleLabel: {
                	        display: true,
                	        labelString: 'distance [km]'
                	      }
                   }]
               },
               onClick : (function(e){chartClickedCallback(e)})
            },
	       	data: {
	       		datasets: [{
                label        : "HLS",
                showLine: true,
                borderColor   : colorHls,
                pointBorderColor       : colorHls,
                legendText  : "HLP",
		        data  : [], // holds the x(driven time) and y(driven distance) values to be displayed on the chart + lat/lon position + link ID
				// mouseover   : chartClickedCallback,
				options: {
					tooltips: {
          			  mode: 'point'
      			  },
				}
		    },
		    {				
                label        : "CRE",
                showLine: true,
                borderColor   : colorFleet,
                pointBorderColor       : colorFleet,
			    data  : [], // holds the x(driven time) and y(driven distance) values to be displayed on the chart + lat/lon position + link ID
				// mouseover   : chartClickedCallback,
				options: {
				tooltips: {
          			  mode: 'point'
      			  },
				}
	        },
		    {				
                label        : "TraceFile",
                showLine: true,
                borderColor   : colorRme,
                pointBorderColor       : colorRme,
			    data  : [], // holds the x(driven time) and y(driven distance) values to be displayed on the chart + lat/lon position + link ID
				// mouseover   : chartClickedCallback,
				options: {
				tooltips: {
          			  mode: 'point'
      			  },
				}
	        }
	        ]}
		});

        $(".show-more a").on("click", function() {
            var $this = $(this); 
            var $content = $this.parent().prev("div.content");
            var linkText = $this.text().toUpperCase();    
            
            if(linkText === "SHOW MORE"){
                linkText = "Show less";
                $content.switchClass("hideContent", "showContent", 400);
            } else {
                linkText = "Show more";
                $content.switchClass("showContent", "hideContent", 400);
            };

            $this.text(linkText);
        });
		
		function chartClickedCallback(e) {
			
			var point = chart.getElementAtEvent(e)[0];
			if (point){
			var dataPoint = chart.config.data.datasets[point._datasetIndex].data[point._index];
			var linkId = dataPoint.linkId;
			var speeds = routeLinkInfos[linkId]; // compare the time needed to get to this link, and the driven speed on this link
            var suppressBreakDuration = document.getElementById("suppressBreakDuration").checked;
            var rmeDriveTime = suppressBreakDuration? Math.round(speeds.drivingTimeRmeWithoutBreaks / 60.0) : Math.round(speeds.drivingTimeRme / 60.0)
			feedbackTxtChartPoint.innerHTML = 'FC' + speeds.fc + ' link ' + linkId + ':  <font color="' + colorRme + '">' + rmeDriveTime + '</font> / <font color="' + colorHls + '">' +
                                    Math.round(speeds.drivingTimeHls / 60.0) + '</font> /  <font color="' + colorFleet + '">' + Math.round(speeds.drivingTimeFleet / 60.0) + '</font> min, <font color="' +
									colorRme + '">' + Math.round(speeds.speedKmhRme) + '</font> / <font color="' + colorHls + '">' + Math.round(speeds.speedKmhHls) + '</font> / <font color="' +
									colorFleet + '">' + Math.round(speeds.speedKmhFleet) + '</font> km/h<br/>';
			if (markerOnRoute == null) { // first time user clicked onto the graph
				markerOnRoute = new H.map.Marker({lat: dataPoint.lat, lng: dataPoint.lng}, { icon: new H.map.Icon(createDiffIcon(rmeDriveTime + "'")) });
				groupDiffMarker.addObject(markerOnRoute);
	            map.addObject(groupDiffMarker);
				groupDiffMarker.setVisibility(true);
			} else {
				markerOnRoute.setPosition({lat: dataPoint.lat, lng: dataPoint.lng});
				markerOnRoute.setIcon(new H.map.Icon(createDiffIcon(rmeDriveTime + "'")));
			}
		
			var ctx=e.target.getContext("2d");
			ctx.beginPath();
			ctx.strokeStyle="gray";
			ctx.moveTo(point._model.x,point._yScale.bottom);
			ctx.lineTo(point._model.x,point._yScale.top);
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(point._xScale.left,point._model.y);
			ctx.lineTo(point._xScale.right,point._model.y);
			ctx.stroke();
			map.setCenter(markerOnRoute.getPosition());
			}
		}

        var samplesObj = {
            "blank": new RouteSample("Choose a pre-defined example here", "", "", "", "", "", ""),
            "mainBrueke": new RouteSample("Route in France with Trace File", "", "sample_france_trace_file.gpx", 
                                          "https://route.api.here.com/routing/7.2/calculateroute.json?mode=fastest;car;traffic:disabled&jsonAttributes=41&legattributes=li&linkattributes=sh,rt",
                                          "https://cre.api.here.com/2/calculateroute.json?mode=fastest;car;traffic:disabled&driver_cost=30&traverseGates=true",
                                          "https://fleet.api.here.com/2/calculateroute.json?routeMatch=1&mode=fastest;car;traffic:disabled")
        };    

        //if an example contains no trace file then an empty ("") value must be passed to traceFileName argument
        function RouteSample(label, content, traceFileName, hlsRequestUrl, fleetRequestUrl, rmeRequestUrl) {
            this.label = label;
            this.content = content;
            this.traceFileName =  traceFileName;
            this.hlsRequestUrl = hlsRequestUrl;
            this.fleetRequestUrl = fleetRequestUrl;
            this.rmeRequestUrl = rmeRequestUrl;

            this.getLabel = function() {
                return label;
            };
            this.getContent = function() {
                return content;
            };

            this.getTraceFileName = function(){
                return traceFileName;
            };

            this.getHlsRequestUrl = function(){
                return hlsRequestUrl;
            };

            this.getFleetRequestUrl = function(){
                return fleetRequestUrl;
            };

            this.getRmeRequestUrl = function(){
                return rmeRequestUrl;
            }
        }

        //adding the event to input trace file text area
        document.getElementById('tracetextarea').addEventListener(
			'dragover', function handleDragOver(evt) {
				evt.stopPropagation();
				evt.preventDefault();
				evt.dataTransfer.dropEffect = 'copy';
			},
			false
        );
        
        document.getElementById('tracetextarea').addEventListener(
		    'drop', function(evt) {
			    evt.stopPropagation();
			    evt.preventDefault();
			    var files = evt.dataTransfer.files;
			    var file = files[0];
			    var r = new FileReader();
			    r.onload = function(e) { 
				    document.getElementById('tracetextarea').value = r.result;
					Spinner.showSpinner();					  
				    calculateRMEMapMatching(document.getElementById("rme_endpoint").value, populateRelevantWaypointsForRouting);
			    }
			    r.readAsText(file);
		    },
		    false
	    );

		map.addEventListener('contextmenu', function(evt) { //right clicked into the map
			var coord = map.screenToGeo(evt.viewportX, evt.viewportY);
			var numCoords = document.getElementById('waypoints').value.trim().split(/\r*\n/).length;
				document.getElementById('waypoints').value += numCoords + "," + parseFloat(coord.lat).toFixed(6) + "," + parseFloat(coord.lng).toFixed(6) + "\n";
				calculateRoute();
		}, false);

        // Tap Event listener has some bug, commenting out for fix
        /*map.addEventListener('tap', function(evt) { // left clicked into map
            var coord = map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY);
			// find the closest trace coordinate
			var minDistance = 100000000.0;
			var closestLink;
			for (var linkId in routeLinkInfos) {
				var link = routeLinkInfos[linkId];
				var distance = coord.distance(link.coord);
				if (distance < minDistance) {
					minDistance = distance;
					closestLink = link;
				}
			}
			var x = closestLink.drivingTimeHls    ; if (x == undefined) x = closestLink.drivingTimeFleet    ; if (x == undefined) x = closestLink.drivingTimeRme    ;
			var y = closestLink.drivingDistanceHls; if (x == undefined) x = closestLink.drivingDistanceFleet; if (x == undefined) x = closestLink.drivingDistanceRme;
			chartClickedCallback({ chart: chart, dataPoint: { x: Math.round(x / 60.0), y: Math.round(y / 1000.0), linkId: closestLink.linkId, lat: closestLink.coord.lat, lng: closestLink.coord.lng } });
        }, false);*/

        /**
        *   Load samples and populate them in the drop down
        */
        var loadSamples = function() {
            for (var routeSample in samplesObj) {
                var opt = document.createElement('option');
                opt.innerHTML = samplesObj[routeSample].getLabel();
                opt.id = routeSample;
                document.getElementById("exampleSelector").appendChild(opt);
            }
        }();
    
        /**
        *	When a sample is selected, show it in the waypoints list
        */
        function exampleSelect(me) {
            var hlsRequestUrlToCall = samplesObj[me.selectedOptions[0].id].getHlsRequestUrl().trim();
            if (hlsRequestUrlToCall){
                document.getElementById('hlp_router_endpoint').value = "";
                document.getElementById('hlp_router_endpoint').value = hlsRequestUrlToCall;
            }
            var fleetRequestUrlToCall = samplesObj[me.selectedOptions[0].id].getFleetRequestUrl().trim();
            if (fleetRequestUrlToCall){
                document.getElementById('fleet_router_endpoint').value = "";
                document.getElementById('fleet_router_endpoint').value = fleetRequestUrlToCall;
            }
            var rmeRequestUrlToCall = samplesObj[me.selectedOptions[0].id].getRmeRequestUrl().trim();
            if (rmeRequestUrlToCall){
                document.getElementById('rme_endpoint').value = "";
                document.getElementById('rme_endpoint').value = rmeRequestUrlToCall;
            }
            var traceFileName = samplesObj[me.selectedOptions[0].id].getTraceFileName().trim();
            if (traceFileName) loadFromFile(traceFileName);
        }

        function calculateRoute() {
            clearAll();
            calculateRouteFleetOrHlp(document.getElementById("hlp_router_endpoint").value, "HLP", processResponseData);
			// the other 2 calls will be triggered within processResponseData, to keep it sequential, for the response time calculation
		}

        function clearAll(){
            feedbackTxt.innerHTML            = "";
            feedbackTxtRME.innerHTML         = "";
			feedbackTxtChartPoint.innerHTML  = "";
            feedbackModeModification.innerHTML = "";									  								
			routeLinkInfos                   = new Object();
			initialRemainTimeHLSRouter       = 0;
            initialRemainTimeFleetRouter     = 0;
            initialRemainTimeRME             = 0;
            chart.config.data.datasets[0].data = [];
            chart.config.data.datasets[1].data = [];
            chart.config.data.datasets[2].data = [];
            rmeDataPoints = [];
            rmeDataPointWithoutBreaks = [];        
            document.getElementById('chartContainer').style.display = 'none'; //hide the chart element
			groupRelevantWayPoints.removeAll();
        }
			
        function calculateRouteFleetOrHlp(endpoint, serviceName, callbackFunction) {
            if(!endpoint) return;
            groupClickedWaypoints.removeAll();
			var urlWayPoints = "";
            if (document.getElementById('waypoints').value.trim() != "") {
                var rawDestArray = document.getElementById('waypoints').value.trim().split(/\r*\n/);
                var firstWayPoint, lastWayPoint;
                for (var i = 0; i < rawDestArray.length; i++) {
                    var coord = rawDestArray[i].split(",");
                    if(i==0) firstWayPoint = coord;
                    if(i==rawDestArray.length-1) lastWayPoint = coord;
					
                    urlWayPoints += '&waypoint' + i + ((i == 0 || i == rawDestArray.length - 1) ? "=" : "=passThrough!") + coord[1] + "," + coord[2];

                }
                if(firstWayPoint){ 
                    var markerS = new H.map.Marker(new Waypoints(firstWayPoint[0], firstWayPoint[1], firstWayPoint[2]),{ icon: new H.map.Icon(createWaypointIcon('S')) });
				    groupClickedWaypoints.addObject(markerS);
                }
                if(lastWayPoint){
                    var markerD = new H.map.Marker(new Waypoints(lastWayPoint[0], lastWayPoint[1], lastWayPoint[2]),{ icon: new H.map.Icon(createWaypointIcon('D')) });
                    groupClickedWaypoints.addObject(markerD);
                }

            }
            var url = checkAndAddAppIdAndCode((endpoint + urlWayPoints),  (serviceName === "HLS" ? 'HLS Route Request' : 'CRE Route Request'));
            if (url) makeAjaxCall (url, serviceName, callbackFunction);
        }

        // route match the GPS trace
        function calculateRMEMapMatching(endpoint, callbackFunction) {
            if (!document.getElementById('tracetextarea').value){ //if there is no trace file then do not call RME.
                return;
            }
           // var zip = new JSZip();
            //zip.file("temp.zip", document.getElementById('tracetextarea').value);
            //var content = zip.generate({type : "base64" , compression: "DEFLATE", compressionOptions : {level:6} });
            // if there is an app_id specified in the URL then use it, otherwise use the default
           // var url = endpoint + "&file=" + encodeURIComponent(content);
            var finalUrl = checkAndAddAppIdAndCode(endpoint, 'RME Request');
            if (finalUrl) makeAjaxCallForPostRequest (finalUrl.concat("&attributes=LINK_FCn(REF_NODE_NEIGHBOR_LINKS,NONREF_NODE_NEIGHBOR_LINKS)"), document.getElementById('tracetextarea').value, "RME", callbackFunction);
        }
        
		var populateRelevantWaypointsForRouting = function(rmeResponse){
            clearAll();
            groupHLP.removeAll();
		    groupFleet.removeAll();
            groupRME.removeAll();
            groupClickedWaypoints.removeAll();
            var routeLinks = rmeResponse.RouteLinks;
            newCalculateResponse = typeof routeLinks != 'undefined' ? false : true;
            if (newCalculateResponse) routeLinks = rmeResponse.response.route[0].leg[0].link; 
            
            var behindIntersection = false;
            relevantWayPointsForRouter = [];
            var metersToDriveBeforeCreatingAnotherRouteRelevantPoint = 0; // prevent too many waypoints for router
            var pointIndex = 0;
            for (var l = 0; l < routeLinks.length; l++) {
                var bestLat = 0, bestLon = 0, maxDist2BetweenShapePoints = 0;
                var coords1 = routeLinks[l].shape;
                var inFrontOfIntersection = (parseInt(routeLinks[l].linkId) >= 0)
                    ? (routeLinks[l].attributes.LINK_FCN[0].NONREF_NODE_NEIGHBOR_LINKS.split(',').length > 1)
                    : (routeLinks[l].attributes.LINK_FCN[0].   REF_NODE_NEIGHBOR_LINKS.split(',').length > 1);
                if ((behindIntersection && metersToDriveBeforeCreatingAnotherRouteRelevantPoint <= 0) || l == 0 || l == routeLinks.length - 1) { // Route relevant. Take the point in the middle of the longest shape point pair distance
                    for (var c = 2; c < coords1.length; c += 2) {
                        var fromLat = parseFloat(coords1[c - 2]), fromLon = parseFloat(coords1[c - 1]), toLat = parseFloat(coords1[c]), toLon = parseFloat(coords1[c +1]); 
                        var dist2 = (toLat - fromLat) * (toLat - fromLat) * 0.4 + (toLon - fromLon) * (toLon - fromLon); // very rough - not projecting into cartesian
                        if (maxDist2BetweenShapePoints < dist2) {
                            maxDist2BetweenShapePoints = dist2;
                            bestLat = (toLat + fromLat) / 2.0;
                            bestLon = (toLon + fromLon) / 2.0;
                        }
                    }
                }
                metersToDriveBeforeCreatingAnotherRouteRelevantPoint -= routeLinks[l].length;
                if (maxDist2BetweenShapePoints > 0) {
                    groupRelevantWayPoints.addObject(new H.map.Marker(new H.geo.Point(bestLat, bestLon), {icon: createIcon("green", pointIndex++)}));
                    relevantWayPointsForRouter.push(Math.round(bestLat * 100000.0) / 100000.0 + "," + Math.round(bestLon * 100000.0) / 100000.0);
                    metersToDriveBeforeCreatingAnotherRouteRelevantPoint = newCalculateResponse? Math.round(rmeResponse.response.route[0].summary.distance / 100.0) : 100; // adapt the metersToDrive to travel distance
                }
                behindIntersection = inFrontOfIntersection;
            }

            map.addObject(groupRelevantWayPoints);
            map.setViewBounds(groupRelevantWayPoints.getBounds());
            
            document.getElementById('waypoints').value = ""; //remove already existing waypoints from the waypoints text area so that the new waypoints from the submitted trace can be shown
            
			for (let i = 0; i < relevantWayPointsForRouter.length; i++){
                let lat = relevantWayPointsForRouter[i].split(',')[0];
                let lng = relevantWayPointsForRouter[i].split(',')[1];
				if (i == 0){
					document.getElementById('waypoints').value += i + ",\t" + (Math.round(lat * 100000.0) / 100000.0) + ",\t" + (Math.round(lng * 100000.0) / 100000.0);
                    var markerS = new H.map.Marker(new Waypoints(i, lat, lng),{ icon: new H.map.Icon(createWaypointIcon('S')) });
			        groupRelevantWayPoints.addObject(markerS);
				} 
                else {
					document.getElementById('waypoints').value += "\n" + i + ",\t" + (Math.round(lat * 100000.0) / 100000.0) + ",\t" + (Math.round(lng * 100000.0) / 100000.0);
                    if(i == relevantWayPointsForRouter.length-1){
                        var markerD = new H.map.Marker(new Waypoints(i, lat, lng),{ icon: new H.map.Icon(createWaypointIcon('D')) });
			            groupRelevantWayPoints.addObject(markerD);
                    }
				}	
			}

            waypoints = rmeResponse.TracePoints;
            var newCalculateResponse = (typeof waypoints != 'undefined' ? false : true);
            if (newCalculateResponse) waypoints = rmeResponse.response.route[0].waypoint;
            var startWaypoint = waypoints[0];
			var endWaypoint = waypoints[waypoints.length - 1];
			var firstTime = new Date(startWaypoint.timestamp);	
			var lastTime = new Date(endWaypoint.timestamp);
			etaTime = (lastTime.getTime() - firstTime.getTime())/(1000*60);

            //check vehicle type confidences and modify routing mode for HLP and Fleet router accordingly

            if(rmeResponse.response.route[0].matchedVehicleType && rmeResponse.response.route[0].matchedVehicleType.length > 0){
                // if we guess it was a truck
                if(rmeResponse.response.route[0].matchedVehicleType[0].type == 'truck'){
                    //console.log("It was a truck");
                    var subType = rmeResponse.response.route[0].matchedVehicleType[0].subType? rmeResponse.response.route[0].matchedVehicleType[0].subType : 'light';
                    var truckSpec;
                    switch(subType) {
                        case 'light':
                            truckSpec = "&limitedWeight=5";
                            break;
                        case 'medium':
                            truckSpec = "&limitedWeight=15";
                            break;
                        case 'heavy':
                            truckSpec = "&limitedWeight=25";
                            break; 
                    }
                    if(truckSpec){
                        var hlp_router_endpoint = document.getElementById("hlp_router_endpoint").value;
                        if(hlp_router_endpoint.search(/;car;/) != -1) 
                            hlp_router_endpoint = hlp_router_endpoint.replace(/;car;/,";truck;");
                        if(hlp_router_endpoint.search(/&limitedWeight/) == -1) // if &limitedWeight is not specified yet
                            hlp_router_endpoint = hlp_router_endpoint.concat(truckSpec);
                        document.getElementById("hlp_router_endpoint").value = hlp_router_endpoint;

                        var fleet_router_endpoint = document.getElementById("fleet_router_endpoint").value;
                        if(fleet_router_endpoint.search(/;car;/) != -1)
                            fleet_router_endpoint = fleet_router_endpoint.replace(/;car;/,";truck;");
                        if(fleet_router_endpoint.search(/&limitedWeight/) == -1) // if &limitedWeight is not specified yet
                            fleet_router_endpoint = fleet_router_endpoint.concat(truckSpec+'t');
                        document.getElementById('fleet_router_endpoint').value = fleet_router_endpoint;
                    }
                }
                // if we guess it was a car
                else if(rmeResponse.response.route[0].matchedVehicleType[0].type == 'car'){
                    //console.log("It was a car");
                    var hlp_router_endpoint = document.getElementById("hlp_router_endpoint").value;
                    if(hlp_router_endpoint.search(/;truck;/) != -1)
                        hlp_router_endpoint = hlp_router_endpoint.replace(/;truck;/,";car;");
                    hlp_router_endpoint = removeLimitedWeight(hlp_router_endpoint);
                    document.getElementById("hlp_router_endpoint").value = hlp_router_endpoint;
                    
                    var fleet_router_endpoint = document.getElementById("fleet_router_endpoint").value;
                    if(fleet_router_endpoint.search(/;truck;/) != -1)
                        fleet_router_endpoint = fleet_router_endpoint.replace(/;truck;/,";car;");
                    fleet_router_endpoint = removeLimitedWeight(fleet_router_endpoint);
                    document.getElementById('fleet_router_endpoint').value = fleet_router_endpoint;
                }
            }
            Spinner.hideSpinner();							  
		};

        function removeLimitedWeight(router_endpoint){
            if(router_endpoint.search(/&limitedWeight=/) != -1){
                var idx = router_endpoint.search(/&limitedWeight=/);
                var startIdx = idx;
                idx += '&limitedWeight='.length;
                while(router_endpoint.charAt(idx) != '&' && router_endpoint.charAt(idx) != '')
                    idx++;
                router_endpoint = router_endpoint.replace(router_endpoint.substring(startIdx, idx), '');
            }
            return router_endpoint;
        }
		
        //function to make an ajax call to the backend server
        function makeAjaxCall(url, serviceName, callbackFunction){
            $.ajax({ url: url, dataType: "json", async: true, type: 'get',
                success: function(data) {
                	callbackFunction(data, serviceName);
                },
                error: function(xhr, status, e) {
                    var routeStrokeColor;
                    if (serviceName == "HLP")
                        routeStrokeColor = colorHls;
                    else
                        routeStrokeColor = colorFleet;
                    if (xhr.responseJSON == undefined){ //in case of an error like GATEWAY_TIMEOUT
                        feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">An error occurred while calling the service</font>';
                        feedbackTxt.innerHTML += "<br/>";
                    }else{ //when the application returns back an error message
                        if (xhr.responseJSON.issues && xhr.responseJSON.issues[0]) feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + xhr.responseJSON.issues[0].message + "</font>";
					    if (xhr.responseJSON.details                             ) feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + xhr.responseJSON.details           + "</font>";
                        feedbackTxt.innerHTML += "<br/>";
                    }
                }
            });
        }

        //function to make an ajax call of type Post to the backend server. RME request should be of type post because it can have huge trace file so get request should be avoided
        function makeAjaxCallForPostRequest(url, payLoad, serviceName, callbackFunction){
            $.ajax({
                url: url,
                dataType: "json",
                async: true,
                type: 'post',
				data: payLoad,
				contentType: 'application/octet-stream',
                success: function(data) {
                	callbackFunction(data, serviceName);
                },
                error: function(xhr, status, e) {
                    if (xhr.responseJSON == undefined){ //in case of an error like GATEWAY_TIMEOUT
                        feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">An error occurred while calling the service</font>';
                        feedbackTxt.innerHTML += "<br/>";
                    }else{ //when the application returns back an error message
                        if (xhr.responseJSON.issues && xhr.responseJSON.issues[0]) feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + xhr.responseJSON.issues[0].message + "</font>";
					    if (xhr.responseJSON.details                             ) feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + xhr.responseJSON.details           + "</font>";
                        feedbackTxt.innerHTML += "<br/>";
                    }
                }
            });
        }
        
        function processResponseData(resp, serviceName){
        	
        	if (serviceName == "HLP"){
        		parseRoutingResponse(resp, colorHls  , colorHls  , groupHLP  ,  1, Date.now());
				calculateRouteFleetOrHlp(document.getElementById("fleet_router_endpoint").value, "Fleet", processResponseData);
        	} else if (serviceName == "Fleet"){
        		parseRoutingResponse(resp, colorFleet, colorFleet, groupFleet, -1, Date.now());
                calculateRMEMapMatching (document.getElementById("rme_endpoint").value, processResponseData);
        	}else if (serviceName == "RME"){
        		parseRoutingResponse(resp, colorRme  , colorRme  , groupRME  , -2, Date.now());
        	}
        }
      
        function parseRoutingResponse(resp, routeStrokeColor, routeFillColor, group, timeDiffSign, startTimeStamp) {
        	group.removeAll();
            //draw the route returned by the RME, as RME response differs than the normal routing response we draw it differntly than the normal router path
            if (timeDiffSign === -2) { // RME response
                var totalBreakDuration = 0; //break duration along the route
                var routeLinks = resp.RouteLinks;
                var newCalculateResponse = typeof routeLinks != 'undefined' ? false : true; //newCalculateResponse == true (RME request is sent to calculateroute.json resource) else matchRoute was called
                if (newCalculateResponse) routeLinks =  resp.response.route[0].leg[0].link;
				var traceLengthMeters = 0;
				var linkFCs = new Object(); // key = linkId with direction sign, value = fc
		        for (var l = 0; l < routeLinks.length; l++) {
			        var coords1 = newCalculateResponse ? routeLinks[l].shape : routeLinks[l].shape.split(" ");
                    var coords2 = new H.geo.Strip();
                    for (var c = 0; c < coords1.length; c += 2) {
                        coords2.pushLatLngAlt(parseFloat(coords1[c]), parseFloat(coords1[c + 1]), null);
                    }
                    var polyline = new H.map.Polyline(coords2, {style: {lineWidth: 18 - 3 * routeLinks[l].functionalClass, strokeColor: routeStrokeColor, fillColor: routeFillColor}}, );
                    polyline.setArrows(true);
                    group.addObject(polyline);
					traceLengthMeters += (newCalculateResponse ? routeLinks[l].length : routeLinks[l].linkLength);
					linkFCs[Math.abs(routeLinks[l].linkId)] = routeLinks[l].functionalClass;
                }
                // Compute the remaining driving time for each trace point
                var tracePoints = resp.TracePoints;
                newCalculateResponse = typeof tracePoints != 'undefined' ? false : true; 
                if (newCalculateResponse) tracePoints = resp.response.route[0].waypoint;
                var timeStampInMSecAtFirstTracePoint = new Date(tracePoints[0                     ].timestamp).getTime();
                var timeStampInMSecAtLastTracePoint  = new Date(tracePoints[tracePoints.length - 1].timestamp).getTime();
				var drivenDistanceMetersUntilCurrentLink = 0;
				var currentLinkIndex = 0;
                for (var m = 0; m < tracePoints.length; m++) {
                    var tp = tracePoints[m];
                    var linkId = newCalculateResponse ? tp.linkId : tp.linkIdMatched;
                    var drivingTimeFromStartInSec = (new Date(tp.timestamp).getTime() - timeStampInMSecAtFirstTracePoint) / 1000;
                    var drivingTimeFromStartInSecWithoutBreak = (new Date(tp.timestamp).getTime() - timeStampInMSecAtFirstTracePoint - totalBreakDuration) / 1000;
                    var drivingTimeFromStart = drivingTimeFromStartInSec / 60.0; // in minutes
                    drivingTimeFromStart = roundTo2DecimalPlaces(drivingTimeFromStart);
                    var drivingTimeFromStartWithoutBreaks = roundTo2DecimalPlaces(drivingTimeFromStartInSecWithoutBreak / 60.0); // in minutes
					var linkSeqNum = tp.routeLinkSeqNrMatched;
					while (currentLinkIndex < linkSeqNum) {
						drivenDistanceMetersUntilCurrentLink += (newCalculateResponse ? routeLinks[currentLinkIndex].length : routeLinks[currentLinkIndex].linkLength);
						currentLinkIndex++;
                    }
                    var currentLinkLength = newCalculateResponse ? routeLinks[currentLinkIndex].length : routeLinks[currentLinkIndex].linkLength;
					var drivenMetersOnCurrentLink = currentLinkLength * ((linkId > 0) ? (newCalculateResponse ? tp.spot : tp.matchOffsetOnLink) : (1.0 - (newCalculateResponse ? tp.spot : tp.matchOffsetOnLink)));
                		
                    if (routeLinkInfos[linkId] == null) routeLinkInfos[linkId] = new Object();
					routeLinkInfos[linkId].drivingTimeRme     = drivingTimeFromStartInSec;
                    routeLinkInfos[linkId].drivingTimeRmeWithoutBreaks = drivingTimeFromStartInSecWithoutBreak;
					routeLinkInfos[linkId].drivingDistanceRme = drivenDistanceMetersUntilCurrentLink + drivenMetersOnCurrentLink;
					routeLinkInfos[linkId].speedKmhRme        = tp.speedMps * 3.6;
                    routeLinkInfos[linkId].fc                 = linkFCs[linkId];
                    var mappedPositionLat                     = newCalculateResponse ? tp.mappedPosition.latitude : tp.latMatched;
                    var mappedPositionLng                     = newCalculateResponse ? tp.mappedPosition.longitude : tp.lonMatched;
					routeLinkInfos[linkId].coord              = new H.geo.Point(mappedPositionLat, mappedPositionLng);
					routeLinkInfos[linkId].linkId             = linkId;
                   if (tp.breakDetected === true && tp.breakDuration !== undefined)
						totalBreakDuration += tp.breakDuration;
                    if (!(tp.breakDetected === true) || tp.breakDuration !== undefined) // if we detected a break but don't know a duration, we don't draw a point
						rmeDataPointWithoutBreaks.push({x: Number(drivingTimeFromStartWithoutBreaks).toFixed(2), y: Number((drivenDistanceMetersUntilCurrentLink + drivenMetersOnCurrentLink) / 1000.0).toFixed(2), lat: mappedPositionLat, lng: mappedPositionLng, linkId: linkId});
					rmeDataPoints                .push({x: Number(drivingTimeFromStart             ).toFixed(2), y: Number((drivenDistanceMetersUntilCurrentLink + drivenMetersOnCurrentLink) / 1000.0).toFixed(2), lat: mappedPositionLat, lng: mappedPositionLng, linkId: linkId});
				}

                var suppressBreakDuration = document.getElementById("suppressBreakDuration").checked;
                chart.config.data.datasets[2].data = suppressBreakDuration ? rmeDataPointWithoutBreaks: rmeDataPoints;

                var firstTpMappedLat = newCalculateResponse ? tracePoints[0].mappedPosition.latitude : tracePoints[0].latMatched;
                var firstTpMappedLng = newCalculateResponse ? tracePoints[0].mappedPosition.longitude : tracePoints[0].lonMatched;

                var lastTpMappedLat = newCalculateResponse ? tracePoints[tracePoints.length - 1].mappedPosition.latitude : tracePoints[tracePoints.length - 1].latMatched;
                var lastTpMappedLng = newCalculateResponse ? tracePoints[tracePoints.length - 1].mappedPosition.longitude : tracePoints[tracePoints.length - 1].lonMatched;

				var firstPoint = new H.geo.Point(firstTpMappedLat, firstTpMappedLng);
				var  lastPoint = new H.geo.Point(lastTpMappedLat, lastTpMappedLng);
				var airlineDistance = firstPoint.distance(lastPoint);
                feedbackTxtRMEWithoutBreaks = '<font color="' + routeStrokeColor + '">' + Math.trunc((timeStampInMSecAtLastTracePoint - timeStampInMSecAtFirstTracePoint- totalBreakDuration) / 60000.0) + " min, " + Math.round(traceLengthMeters / 1000.0) + " km" +
                                         ", airline " + Math.round(airlineDistance/1000.0) + " km</font><br/>";

                feedbackTxtRMEWithBreaks = '<font color="' + routeStrokeColor + '">' + Math.trunc((timeStampInMSecAtLastTracePoint - timeStampInMSecAtFirstTracePoint) / 60000.0) + " min, " + Math.round(traceLengthMeters / 1000.0) + " km" +
                                         ", airline " + Math.round(airlineDistance/1000.0) + " km</font><br/>";

                feedbackTxtRME.innerHTML += suppressBreakDuration ? feedbackTxtRMEWithoutBreaks : feedbackTxtRMEWithBreaks;

                //feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + Math.trunc((timeStampInMSecAtLastTracePoint - timeStampInMSecAtFirstTracePoint- totalBreakDuration) / 60000.0) + " min, " + Math.round(traceLengthMeters / 1000.0) + " km" +
				//                         ", airline " + Math.round(airlineDistance/1000.0) + " km</font><br/>";			
                
                // add warnings message for stops
                var warnings = newCalculateResponse ? resp.warnings : resp.Warnings;
                if (warnings){
                     //for each warning that is related to the stop time, get the trace point sequence number
                     for (var w=0; w<warnings.length; w++) {
                         var warningMsg = newCalculateResponse ? warnings[w].message : warnings[w].text;
                         var warningCode = newCalculateResponse ? warnings[w].code : warnings[w].category;
                         if (warningMsg && warningCode == 1010){
                             if (warnings[w].tracePointSeqNum !== -1) {
                                 var tracePointSeqNum = warnings[w].tracePointSeqNum;
                                 if (tracePointSeqNum){ 
                                     var tracePointLength = newCalculateResponse ? resp.response.route[0].waypoint : resp.TracePoints.length;
                                         if (tracePointSeqNum < tracePointLength){
                                        	     //get trace point coordinates and add warning icon on the map
                                                 var tracePoint = resp.TracePoints[tracePointSeqNum];
                                                 var tracePointMappedLat = newCalculateResponse ? tracePoint.mappedPosition.latitude : tracePoint.latMatched;
                                                 var tracePointMappedLng = newCalculateResponse ? tracePoint.mappedPosition.longitude : tracePoint.lonMatched;
                                                 var point = new H.geo.Point(parseFloat(tracePointMappedLat), parseFloat(tracePointMappedLng));
                                                 var marker = new H.map.Marker(point, { icon: createWarningIconMarker(warningMsg, "", 'Default') });
                                                 groupRME.addObject(marker);
                                             }
                                         }
                                     }    
                             }
                         }
                }
            } else { // a Router response
                var totalDistanceDrivenMeter = 0;
                if (resp.response.route[0].leg.length > 1) { alert("Routes with stopOver way points are not supported"); }
                for (var linkIdx = 0; linkIdx < resp.response.route[0].leg[0].link.length; linkIdx++) { // we just take the first alternative, and the route must have only one leg (no stopOver way points)
					var link = resp.response.route[0].leg[0].link[linkIdx];
                    var strip = new H.geo.Strip();
				    var remainTime = link.remainTime; // remaining time to destination when entering this link
                    var linkId     = link.linkId.replace('+','');
					var previousP;
					var linkLengthMeter = 0;
                    for (var i = 0; i < link.shape.length; i += 2) {
						var p = new H.geo.Point(parseFloat(link.shape[i]), parseFloat(link.shape[i + 1]));
                        strip.pushPoint(p);
						if (i > 0 ) linkLengthMeter += p.distance(previousP);
						previousP = p;
                    }
					totalDistanceDrivenMeter += linkLengthMeter;
					var routersSpeedOInLink = linkLengthMeter * 3.6 / ((linkIdx == resp.response.route[0].leg[0].link.length - 1) ? remainTime : (remainTime - resp.response.route[0].leg[0].link[linkIdx + 1].remainTime));
					if (routeLinkInfos[linkId] == null) routeLinkInfos[linkId] = new Object();
					if (timeDiffSign ==  1) { // HLS Router
					    if (initialRemainTimeHLSRouter == 0) initialRemainTimeHLSRouter = remainTime;
                        chart.config.data.datasets[0].data.push({x: Number((initialRemainTimeHLSRouter - remainTime) / 60.0).toFixed(2), y: Number(totalDistanceDrivenMeter / 1000.0).toFixed(2), lat: link.shape[0], lng: link.shape[1], linkId: linkId});
                        routeLinkInfos[linkId].drivingTimeHls     = initialRemainTimeHLSRouter - remainTime;
						routeLinkInfos[linkId].drivingDistanceHls = totalDistanceDrivenMeter;
						routeLinkInfos[linkId].speedKmhHls        = routersSpeedOInLink;
					} else { // Fleet Router
					    if (initialRemainTimeFleetRouter == 0) initialRemainTimeFleetRouter = remainTime;
                        chart.config.data.datasets[1].data.push({x: Number((initialRemainTimeFleetRouter - remainTime) / 60.0).toFixed(2), y: Number(totalDistanceDrivenMeter / 1000.0).toFixed(2), lat: link.shape[0], lng: link.shape[1], linkId: linkId});
                        routeLinkInfos[linkId].drivingTimeFleet     = initialRemainTimeFleetRouter - remainTime;
						routeLinkInfos[linkId].drivingDistanceFleet = totalDistanceDrivenMeter;
						routeLinkInfos[linkId].speedKmhFleet        = routersSpeedOInLink;
 					}
					routeLinkInfos[linkId].coord = new H.geo.Point(parseFloat(link.shape[0]), parseFloat(link.shape[1]));
					routeLinkInfos[linkId].linkId = linkId;
                    var lineWidth = timeDiffSign == -1? 8 : 4;
                    var polyline = new H.map.Polyline(strip, {style: {lineWidth: lineWidth, strokeColor: routeStrokeColor, fillColor: routeFillColor}});
                    polyline.setArrows(true);
                    group.addObject(polyline);
                }
                feedbackTxt.innerHTML += '<font color="' + routeStrokeColor + '">' + Math.round(resp.response.route[0].summary.baseTime / 60.0) + " / " +
										 Math.round(resp.response.route[0].summary.trafficTime / 60.0) + " min, " + Math.round(resp.response.route[0].summary.distance / 1000.0) + " km, " +
										 (Date.now() - startTimeStamp) + " ms resp.time</font><br/>";
            }
            map.addObject(group);
            map.setViewBounds(group.getBounds());
            groupHLP.setVisibility  (true);
            groupFleet.setVisibility(true);
            groupRME.setVisibility  (true);
            document.getElementById("chartContainer").style.display='block';
		    // document.getElementById("chartContainer").style.overflow = 'scroll';
		    //document.getElementById("chartContainer").style.height="400px"; 
		    //document.getElementById("chartContainer").style.width="100%"; 
		    chart.update();
        }

        // if user put app_id/app_code into the request, we use it. Otherwise we use the TCS default app_id.
        function checkAndAddAppIdAndCode(url, requestFieldName){
            var appIdRegEx= /[\?&]app_id=/i;
            var appCodeRegEx= /[\?&]app_code=/i;
            if( url.search( appIdRegEx ) === -1 && url.search( appCodeRegEx ) === -1 ) {
                if( ! url.endsWith( "&" ) ) url= url.concat( "&" );
                url= url.concat( "app_id=" + app_id + "&app_code=" + app_code );
            }
            if( ( url.search( appIdRegEx ) >= 0 && url.search( appCodeRegEx ) < 0 ) || ( url.search( appIdRegEx ) < 0 && url.search( appCodeRegEx ) >= 0 ) ) {
                alert('If you provide credentials in the '+ requestFieldName +' field, please provide both app_id AND app_code.');                
                return;
            }
            return url;
        }

        function removeChartData(chart) {
            chart.config.data.datasets[0].data = [];
            chart.config.data.datasets[1].data = [];
            chart.config.data.datasets[2].data = [];
            chart.update();
        }

        var loadFromFile = function (filename) {
		    var req = new XMLHttpRequest();
		    req.open('GET', '/sample_data/' + filename);
		    req.onreadystatechange = function() {
			    if (req.readyState != XMLHttpRequest.DONE) return;
                document.getElementById('tracetextarea').value = req.responseText;
                calculateRMEMapMatching(document.getElementById("rme_endpoint").value, populateRelevantWaypointsForRouting);
                //calculateRoute(); //calculate route function is only called once the trace file is completely loaded into the text box
		    }
		    req.send();
        }
        
        function extractStartPoint(){
            var startPoint;
            if (document.getElementById('waypoints').value.trim() != "") {
                var rawDestArray = document.getElementById('waypoints').value.trim().split(/\r*\n/);
                var coord = rawDestArray[0].split(",");
                startPoint = new H.geo.Point(coord[1], coord[2]);
            }
            return startPoint;
        }
        
        //--- Create marker with text line
        var createWarningIconMarker = function (line1) {
        	
        	var svgMarker = svgMarkerImage_DriverShortRestTime;
            var width = line1.length * 5 + 45;
            svgMarker = svgMarker.replace(/__line1__/g, line1);
            svgMarker = svgMarker.replace(/__width__/g, width);
            svgMarker = svgMarker.replace(/__widthAll__/g, line1.length * 6 + 60);
            svgMarker = svgMarker.replace(/font-size=\"8\"/g, 10);
            return new H.map.Icon(svgMarker, { anchor: new H.math.Point(18, 48)	});
        };

        //This method will round the value to 2 decimal places
        function roundTo2DecimalPlaces(value){
            return(Math.round(value * 100) / 100);
        }

        var createIcon = function (color, text) {
            var div = document.createElement("div");
            var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="28px" height="16px">' +
                '<line x1="14"  y1="16" x2="14" y2="9" stroke="' + color + '"/>' +
                '<text font-size="10" x="14" y="8" text-anchor="middle" fill="' + color + '">' + text + '</text>' +
                '</svg>';
            div.innerHTML = svg;
            return new H.map.Icon(svg, {anchor: {x : 14, y : 16}});
	    };

        var createWaypointIcon = function(waypointId) {
            return '<svg xmlns="http://www.w3.org/2000/svg" width="28px" height="36px">' +
			  '<path d="M 19 31 C 19 32.7 16.3 34 13 34 C 9.7 34 7 32.7 7 31 C 7 29.3 9.7 28 13 28 C 16.3 28 19' +
			  ' 29.3 19 31 Z" fill="#000" fill-opacity=".2"/>' +
			  '<path d="M 13 0 C 9.5 0 6.3 1.3 3.8 3.8 C 1.4 7.8 0 9.4 0 12.8 C 0 16.3 1.4 19.5 3.8 21.9 L 13 31 L 22.2' +
			  ' 21.9 C 24.6 19.5 25.9 16.3 25.9 12.8 C 25.9 9.4 24.6 6.1 22.1 3.8 C 19.7 1.3 16.5 0 13 0 Z" fill="#fff"/>' +
			  '<path d="M 13 2.2 C 6 2.2 2.3 7.2 2.1 12.8 C 2.1 16.1 3.1 18.4 5.2 20.5 L 13 28.2 L 20.8 20.5 C' +
			  ' 22.9 18.4 23.8 16.2 23.8 12.8 C 23.6 7.07 20 2.2 13 2.2 Z" fill="#1188DD"/>' +
			  '<text font-size="11" font-weight="bold" fill="#fff" font-family="Nimbus Sans L,sans-serif" text-anchor="middle" x="45%" y="50%">' + waypointId + '</text>' +
			  '</svg>';
        };
        var createDiffIcon = function(speeds) {
            return '<svg xmlns="http://www.w3.org/2000/svg" width="28px" height="36px">' +
			  '<path d="M 19 31 C 19 32.7 16.3 34 13 34 C 9.7 34 7 32.7 7 31 C 7 29.3 9.7 28 13 28 C 16.3 28 19' +
			  ' 29.3 19 31 Z" fill="#000" fill-opacity=".2"/>' +
			  '<path d="M 13 0 C 9.5 0 6.3 1.3 3.8 3.8 C 1.4 7.8 0 9.4 0 12.8 C 0 16.3 1.4 19.5 3.8 21.9 L 13 31 L 22.2' +
			  ' 21.9 C 24.6 19.5 25.9 16.3 25.9 12.8 C 25.9 9.4 24.6 6.1 22.1 3.8 C 19.7 1.3 16.5 0 13 0 Z" fill="orange" fill-opacity="1.0"/>' +
			  '<text font-size="11" font-weight="bold" fill="black" font-family="Nimbus Sans L,sans-serif" text-anchor="middle" x="45%" y="50%">' + speeds + '</text>' +
			  '</svg>';
        };
        
    	var svgMarkerImage_DriverShortRestTime = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="svg3721" version="1.1" height="45" width="__widthAll__">'+ 
        '<metadata id="metadata3727"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><defs id="defs3725" />'+
        ' <g transform="translate(-8.5,-9.5)" id="g3719">'+
        ' <rect style="fill:#ffffff;stroke:#000000" x="45" y="11" width="__width__" height="30" rx="3" ry="3" id="label-box" />'+ 
        '<text style="font-weight:bold;font-size:12px;font-family:Sans-serif;text-anchor:start;fill:#000000;stroke-width:0" x="55" y="32" font-weight="bold" font-size="12" xml:space="preserve" id="label-text">__line1__</text>'+
        '<image id="image3717" xlink:href="data:image/png;base64,R0lGODlhfQDCAPQdAAELHgEMHgIMHw8LHRALHR8KGyAKGxEbLCEqOzE5SUBIVkFIV2Fnc3B1gHF2gYCFjoCFj4+UnJCVnZ+jqqCkq6+yuLCzuc/R1NDS1d/g4uDh4+/v8PDw8f///wAAAAAAACH5BAEAAB4ALAAAAAB9AMIAAAX+oCeOJCmcaKqubOu+cCyvZW2XxKzvfO+vhNvN8Csaj0eD0IRsOp+vpQdKrUKF1qy2aNt6v7MSEUwup5Qjs9o8yq3f3uAUTteK6vjqPc9v7vuAP3OBhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnCkICwoMEA4KCwidWgsSGB2trq+uFxEKqEcHHhUcsLu8HRsTHge1OwgTvcfIE6fDLwcQyNDIEMLMKs4b0dm9G9PVJwkZ2uK9GQnVDOPpvQzDEervuxGdBxXw9q8V1JgHF/f+rRf0VeL3r2DAS/UKFqxgSYLChxIooXv4kF2kBBQzmnt0IFzGhxkELnr2kSIERwf+sJV8uEEkIpIrH55chCDmx2WJKNjMSEHRgZ0fXQaaCLRiIgtFKfZEpDJpwQ2IFjiluOCQw6kKIxrqh9Xgoa4Pv4ItaKjm2H84AUk9668qobVs7bkNBDPuOweF6tpNN5PuXnh43/59N1ftYHWF+2A8PC4tIMbjxELOdojVZGgYrF6GprUQ3M28EgfSBXoXh6Oldy09RDR1K4uHfrp2JTSQztmrEZl17fiQ3st9fZLezKG2od+Mgy86oGGzhoubN0JqPRh2pKuDO09C+tfCpQOW42IwzjH82PGaDnAHa4H8JOxTtXOiDtQ6qgTNgWqQzszZ8I8cKOeNMyV14w0LCNz+VhAFvR1oDQMU/CcOBxQw4J6DKqhi3jGyiIZhD58s4MAoC5jy4Ykopqjiiiy26OKLMMYo44w01mgjIIPcqMMfOoaRY48x8AgkDCIMMGQMA6RxZBQjFLBkCwWU8CQLXUyJAhZWShEJAAIE0GUAYIYp5phenkAmmCpw2YIUIjjZiJpbwKlClGyOYOQiclYBQJ4nJFknloXwCcWeKfxp6KGIJiplFn4q6uijkNagRaORVmrpoYxeqummS2TK6aeg/ugEpaGWGqkVpJqqaqJjXLHqq47qAeush7bqBK24/klFrrwuYSsSvQZb5a3CFiuCG34Ya+wTyhqL7BHNLptstMHTEktttcBeiy202m7LRbe9Zgsur9yOm2u55uJqRLrkfsuuuoK8C68P8uL664710upDqvmaei+S/erLA78Bh/qsDAQXDOrACsN6MAwJN8zpDhFLrOnDLlRs8aX4bqxqxx6b6mPIIstA8qomn1wykSqv7ELLLq8Jc6ksz7wwkzbfLHPOn+LM86b/nvCzzjQMzWnQRvdMZdKbYsz0xEU/fenDUm8addWVHoy1pipszTEKGnuta59iWwp22WYLEDbaWqrNdqVuvw1p3HI/unbdeOetN6whAAA7"       y="9.5"       x="8.5"       height="50"       width="50" />  </g>  <rect     y="4.5"     x="13.412357"     height="25"     width="23.5"     id="rect3861" />  <g     style="fill:#ffffff"     transform="matrix(0.09990754,0,0,0.08348614,11.03459,3.066264)"     id="g3859">    <g       style="fill:#ffffff"       id="g3802">      <path         style="fill:#ffffff"         d="m 212.481,159.416 v -9.055 c 0,-5.523 -4.477,-10 -10,-10 H 41.191 c -5.523,0 -10,4.477 -10,10 v 37.355 c 0,31.348 15.997,59.028 40.255,75.312 h -7.01 c -5.523,0 -10,4.477 -10,10 0,5.523 4.477,10 10,10 h 114.799 c 5.523,0 10,-4.477 10,-10 0,-5.523 -4.477,-10 -10,-10 h -7.01 c 8.39,-5.632 15.789,-12.628 21.882,-20.667 h 16.228 c 22.883,0 41.5,-18.617 41.5,-41.5 0.001,-22.164 -17.463,-40.325 -39.354,-41.445 z m -161.29,28.3 v -27.355 h 141.29 v 27.355 c 0,38.954 -31.691,70.645 -70.645,70.645 -38.954,0 -70.645,-31.692 -70.645,-70.645 z m 159.145,34.645 h -4.742 c 4.434,-10.679 6.887,-22.38 6.887,-34.645 v -8.246 c 10.851,1.08 19.355,10.26 19.355,21.391 0,11.855 -9.645,21.5 -21.5,21.5 z"         id="path3798" />      <path         style="fill:#ffffff"         d="m 93.674,118.512 c 5.523,0 10,-4.477 10,-10 0,-0.075 -0.01,-0.148 -0.011,-0.223 5.822,6.282 14.135,10.223 23.354,10.223 5.523,0 10,-4.477 10,-10 0,-0.075 -0.01,-0.148 -0.011,-0.222 5.822,6.281 14.135,10.222 23.354,10.222 5.523,0 10,-4.477 10,-10 0,-5.523 -4.477,-10 -10,-10 -6.536,0 -11.853,-5.317 -11.853,-11.853 0,-2.138 0.573,-4.23 1.656,-6.049 L 178.83,32.478 c 1.976,-3.317 3.02,-7.117 3.02,-10.989 C 181.851,9.641 172.21,0 160.36,0 c -5.523,0 -10,4.477 -10,10 0,5.523 4.477,10 10,10 0.822,0 1.491,0.668 1.491,1.49 0,0.278 -0.066,0.525 -0.203,0.754 L 132.98,70.378 c -2.926,4.913 -4.472,10.543 -4.472,16.282 0,4.541 0.962,8.86 2.682,12.773 -1.271,-0.585 -2.681,-0.921 -4.172,-0.921 -6.536,0 -11.853,-5.317 -11.853,-11.853 0,-2.139 0.572,-4.23 1.656,-6.049 l 28.667,-48.132 c 1.976,-3.317 3.02,-7.117 3.02,-10.989 0,-11.85 -9.641,-21.49 -21.49,-21.49 -5.523,0 -10,4.477 -10,10 0,5.523 4.477,10 10,10 0.822,0 1.49,0.668 1.49,1.49 0,0.278 -0.066,0.525 -0.203,0.754 L 99.637,70.377 c -2.926,4.912 -4.473,10.542 -4.473,16.283 0,4.541 0.962,8.86 2.682,12.773 -1.271,-0.585 -2.682,-0.921 -4.173,-0.921 -6.536,0 -11.853,-5.317 -11.853,-11.853 0,-2.138 0.573,-4.23 1.656,-6.049 l 28.667,-48.132 c 1.976,-3.317 3.02,-7.117 3.02,-10.989 0,-11.85 -9.641,-21.49 -21.491,-21.49 -5.523,0 -10,4.477 -10,10 0,5.523 4.477,10 10,10 0.822,0 1.491,0.668 1.491,1.49 0,0.278 -0.066,0.525 -0.203,0.754 L 66.295,70.377 c -2.926,4.913 -4.473,10.543 -4.473,16.283 0,17.563 14.289,31.852 31.852,31.852 z"         id="path3800" />    </g><g style="fill:#ffffff" id="g3804" /><g style="fill:#ffffff" id="g3806" /><g  style="fill:#ffffff"  id="g3808" /><g style="fill:#ffffff" id="g3810" /><g style="fill:#ffffff" id="g3812"/><g style="fill:#ffffff" id="g3814" /><g  style="fill:#ffffff" id="g3816"/><g style="fill:#ffffff" id="g3818"/><g style="fill:#ffffff" id="g3820" /><g  style="fill:#ffffff"  id="g3822" /><g  style="fill:#ffffff"  id="g3824" /><g  style="fill:#ffffff" id="g3826" /><g style="fill:#ffffff" id="g3828" /><g  style="fill:#ffffff"  id="g3830" /><g style="fill:#ffffff" id="g3832" /></g></svg>';
	</script>